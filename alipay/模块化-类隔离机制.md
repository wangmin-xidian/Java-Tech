******************************************
**SOFABoot 模块化和类隔离机制     2019-03-19**
*****************************************

1. 系统模块化 [引用](https://www.sofastack.tech/posts/2018-07-25-01)
  - [常见的模块化形式](https://www.sofastack.tech/posts/2018-07-21-01)
    - **基于代码组织上的模块化**：最常见形式，在开发期，将不同功能的代码放到不同的Java工程下，在编译期build成不同的jar，在运行期，所有的Java类在一个classpath下且使用同一个Spring上下文，没有做任何隔离；
    - **基于Spring上下文隔离的模块化**：使用Spring上下文来做不同功能模块的隔离，在开发期和编译期，代码和配置也会分在不同的Java工程中，但在运行期，不同的Spring Bean相互不可见，IoC只在同一个上下文内部发生，但是所有的Java类还是在一个ClassLoader下；
    - **基于ClassLoader隔离的模块化**：借用ClassLoader来做隔离，每个模块都有独立的ClassLoader，模块与模块之间的classpath不同，`SOFAArk`是此模式化的实践方式。

  - 传统模块化的陷阱
    - 多个模块间调用所需service层，模块间耦合很大，很难做系统拆分、模块化。
  
  - OSGi模块化
    - 使用ClassLoader机制，将模块和模块间的类完全隔离，当模块间需要引用时，通过在Manifest.mf文件中声明类的导入和导出解决；
    - OSGi的声明式服务：在模块中添加xml配置文件声明服务，同样地，使用xml配置文件引用其他模块的声明；
    
    - OSGi通过类隔离机制解决了模块间的类隔离问题，通过声明式服务的方式解决了模块间的服务调用的问题。模块和模块间的边界更加明确清晰。但再实践过程中，OSGi类隔离带来的复杂性，OSGi每个模块都通过独立的ClassLoader去加载，在开发过程中，要求非常清楚地定义声明和引用。学习成本和实践成本较高。
  
  - SOFA 模块化
    - 为了解决传统模块化方案模块化不彻底的问题，以及OSGi彻底模块化带来的复杂性的问题，SOFA引入了一种折中的模块化方案：
    - 给每个模块都提供一个单独的Spring上下文，通过Spring上下文的隔离，让模块和模块之间的Bean引用无法直接进行，达到模块在运行时隔离的能力；
    - 当一个模块需要调用另一个模块里面的一个Bean时，SOFA采用了类似于OSGi的声明式服务方式，通过配置文件配置声明和引用。
    
  - SOFABoot提供了两种形式的服务发布和引用，用来解决不同级别的模块间调用问题：
    - JVM服务发布和引用：解决一个SOFABoot应用内部各个SOFABoot模块之间的调用问题；
    - RPC服务发布和引用：解决多个SOFABoot应用之间的远程调用问题

2. 类隔离机制 - [SOFAArk](https://zhuanlan.zhihu.com/p/36909393)









