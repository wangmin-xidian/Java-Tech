**线程池的理解**
-----------------------------------
-----------------------------------
目录
  1. 创建线程的方法
  2. 线程池的由来
  3. 线程池的原理
  4. 线程池的核心参数
  5. 线程池的阻塞&拒绝策略
  6. 线程池的监控
  7. 线程池的使用建议
------------------------------------


**1. 创建线程的方法**
  - 1. 继承Thread类   
  - 2. 实现Runnable接口
  - 3. 实现Callable接口    
  - 4. 使用线程池创建
  
 单线程创建方式的对比
   - Java的类只能单继承，若使用继承Thread，则不能再继承其他类；  
   - 实现Runnable的方式，接口可以多实现；
   - Callable执行的方法是call(), Runnable执行的方法是run()；


**2. 线程池的由来**   
  使用继承类或实现接口的方式创建线程，线程的创建和销毁都需要内存，若线程数量太多，频繁的创建和销毁线程会大大浪费时间和效率，同时会浪费内存。
  因此出现了线程池，创建的线程运行完不立即销毁，让线程**重复利用，避免重复开销**。

  - 多线程的优点(提高CPU使用效率，提高工作效率)   
    1. 线程是稀缺资源，使用线程池可以减少创建和销毁线程的次数，每个工作线程都可以重复使用。  
    2. 可以根据系统的承受能力，调整线程池中工作线程的数量，防止因为消耗过多内存导致服务器崩溃。
  
  - 多线程的缺点   
    1. **消耗更多的内存资源，出现资源不足**  
      线程消耗包括内存和其它系统资源在内的大量资源，线程很多时，会消耗很多额外的系统资源，虽然说线程间切换切换消耗很小，同样线程数目很多时，环境切换也可能严重地影响程序的性能。
      
    2. **出现资源竞争，发生死锁**  
      任何多线程之间都可能会会有死锁现象。  
    3. **并发错误**  
      线程池和其它排队机制依靠使用 wait() 和 notify() 方法，这两个方法都难于使用。如果编码不正确，那么可能丢失通知，导致线程保持空闲状态，尽管队列中有工作要处理。
    4. **线程泄露**  
      各种类型的线程池中一个严重的风险是线程泄漏，当从池中除去一个线程以执行一项任务，而在任务完成后该线程却没有返回池时，会发生这种情况。发生线程泄漏的一种情形出现在任务抛出一个 RuntimeException 或一个 Error 时。
      如果池类没有捕捉到它们，那么线程只会退出而线程池的大小将会永久减少一个。当这种情况发生的次数足够多时，线程池最终就为空，而且系统将停止，因为没有可用的线程来处理任务。
    5. **请求过载**  
      仅仅是请求就压垮了服务器，这种情况是可能的。在这种情形下，将每个到来的请求都排队到工作队列，排在队列中等待执行的任务可能会消耗太多的系统资源并引起资源缺乏。
  
**3. 线程池的原理**
  - 线程池的状态   
    在ThreadPoolExecutor类中定义了一个volatile变量runState来表示线程池的状态，线程池有四种状态，分别为RUNNING、SHURDOWN、STOP、TERMINATED。
    1. 线程池创建后处于RUNNING状态。
    2. 调用shutdown后处于SHUTDOWN状态，线程池不能接受新的任务，会等待缓冲队列的任务完成。 
    3. 调用shutdownNow后处于STOP状态，线程池不能接受新的任务，并尝试终止正在执行的任务。 
    4. 当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态。
  
  - 线程池的原理   
    当系统接受一个提交的任务时，并不会着急去创建一个新的线程去执行这个任务，而是去线程池中查询是否有空闲的线程。
     1. 若有：直接使用这个线程。
     2. 若没有：根据配置的策略执行（有可能时创建一个新的线程，也有可能是阻塞该任务等待空闲线程）。
     3. 待任务结束之后，也不会销毁线程，而是放入线程池的空闲队列，等待下次使用。
    
  - 线程池的处理流程     
    1. 判断线程池里的核心线程是否都在执行任务，如果不是（核心线程空闲或者还有核心线程没有被创建）则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则进入下个流程。  
    2. 线程池判断工作队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。  
    3. 判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。
  
  - 线程池中重要的类   
    1. **Executor**      
      Java中线程池的顶级接口，可以称它为一个执行器，通过查看源码也知道，他只有一个简单的方法execute(Runnable command)，就是用来执行提交的任务
    2. **ExecutorService**    
      Executor的子类，也是真正的线程池接口。它提供了提交任务和关闭线程池等方法。调用submit方法提交任务还可以返回一个Future对象，利用该对象可以了解任务执行情况，获得任务的执行结果或取消任务。
    3. **Executors**    
      由于线程池配置比较复杂，自己配置的线程池可能性能不是最好的。Executors就是用来方便创建各种常用线程池的工具类。
    4. **ThreadPoolExecutor**    
      ExecutorService的默认实现，Executors创建各种线程池的时候内部其实就是调用了ThreadPoolExecutor的构造方法。
  
  - Executors的线程池实现   
    1. **newCachedThreadPool** 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
    2. **newFixedThreadPool** 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
    3. **newScheduledThreadPool** 创建一个定长线程池，支持定时及周期性任务执行。
    4. **newSingleThreadExecutor** 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。

**4. 线程池的核心参数**
  - **corePoolSize**：核心线程数，如果运行的线程数少于corePoolSize，当有新的任务过来时会创建新的线程来执行这个任务，即使线程池中有其他空闲的线程
  - **maximumPoolSize**：线程池中允许的最大线程数。
  - **keepAliveTime**：如果线程数多于核心线程数，那么这些多出来的线程如果空闲时间超过keepAliveTime将会被终止。
  - **unit**：keepAliveTime参数的时间单位。
  - **workQueue**：任务队列，通过线程池的execute方法会将任务Runnable存储在队列中。
  - **threadFactory**：线程工厂，用来创建新线程。
  - **handler**：添加任务出错时的策略捕获器，默认是ThreadPoolExecutor.AbortPolicy ，即添加任务出错就直接抛出异常 。

**5. 线程池的阻塞&拒绝策略**
  - **runnableTaskQueue** 用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列：
    1. ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。
    2. LinkedBlockingQueue：一个基于链表结构的阻塞队列，无界队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。
    3. SynchronousQueue：一个不存储元素的阻塞队列。直接提交，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。
    4. PriorityBlockingQueue：一个具有优先级得无限阻塞队列。
    
  - **RejectedExecutionHandler** 当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。
  这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。以下是JDK1.5提供的四种策略。
    1. AbortPolicy：直接抛出异常。
    2. CallerRunsPolicy：只用调用者所在线程来运行任务。
    3. DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。
    4. DiscardPolicy：不处理，丢弃掉。
  当然也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务。

**6. 线程池的监控**
  如何监控线程池中线程状态，具体方法有：
  - 1. 使用JVM命令，jps,jstak  
  - 2. 使用ThreadPoolExecutor本身自带的API   
    - 1. 扩展ThreadPoolExecutor，重写beforeExecute和afterExecute，在这两个方法里分别做一些任务执行前和任务执行后的相关监控逻辑，还有个terminated方法，是在线程池关闭后回调。
    - 2. 线程池执行类ThreadPoolExecutor也给出了相关的 API, 能实时获取线程池的当前活动线程数、正在排队中的线程数、已经执行完成的线程数、总线程数。
  - 3. 使用CountDownLatch 也可判断线程池中的线程是否执行完毕。   
    用给定的计数初始化CountDownLatch，其含义是要被等待执行完的线程个数。每次调用CountDown()，计数减1，主程序执行到await()函数会阻塞等待线程的执行，直到计数为0。

**7. 线程池的使用建议**    
  1. 建议使用new ThreadPoolExecutor(...)的方式创建线程池    
    不使用 Executors 去创建，而应该通过 ThreadPoolExecutor 创建，这样可以让读者更加明确地知道线程池的参数设置、运行规则，规避资源耗尽的风险。
  2. 合理设置线程数   
    如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 NCPU+1     
    如果是IO密集型任务，参考值可以设置为2*NCPU      
    具体的设置还需要根据实际情况进行调整，比如可以先将线程池大小设置为参考值，再观察任务运行情况和系统负载、资源利用率来进行适当调整。
  3. 设置能代表具体业务的线程名称     
    这样方便通过日志的线程名称识别所属业务。具体实现可以通过指定ThreadPoolExecutor的ThreadFactory参数。如使Spring提供的CustomizableThreadFactory。
  
  

Reference：    
https://www.toutiao.com/i6614005147502641671/   
https://www.toutiao.com/a6492891925958361613/   
https://www.toutiao.com/i6621053271307977229/   
https://www.toutiao.com/i6613946451665879566/   
