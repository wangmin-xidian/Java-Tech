**缓存的理解**
----------------------------
1. 缓存技术的详解
link : https://blog.csdn.net/qq_26517369/article/details/78330694

2. 缓存穿透，缓存击穿，缓存雪崩解决方案分析
https://blog.csdn.net/zeb_perfect/article/details/54135506

3. 缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题
https://blog.csdn.net/xlgen157387/article/details/79530877

4. Redis总结（五）缓存雪崩和缓存穿透等问题
http://www.cnblogs.com/zhangweizhong/p/6258797.html

5. 电商系统总结
https://www.cnblogs.com/zhangweizhong/category/879056.html

6. 开发高并发系统时保护系统的三把利器：缓存、降级和限流
https://blog.csdn.net/zc529739024/article/details/78744876

**缓存穿透**
  - 场景     
    缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。
  
  - 解决办法 
    - 最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。    
    - 如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库。

**缓存击穿**    
  - 场景     
  对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。
  缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。

  
  - 解决办法    
    - 使用互斥锁
    - "提前"使用互斥锁
    

**缓存雪崩**
